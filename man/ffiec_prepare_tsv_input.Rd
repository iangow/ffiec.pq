% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ffeic_read.R
\name{ffiec_prepare_tsv_input}
\alias{ffiec_prepare_tsv_input}
\title{Prepare a robust TSV input source from a Call Report file inside a ZIP}
\usage{
ffiec_prepare_tsv_input(
  zipfile,
  inner_file,
  skip = 2L,
  expected_cols,
  tolerance = 0L,
  row_start_re = "^\\\\d+\\\\t"
)
}
\arguments{
\item{zipfile}{Character scalar. Path to a ZIP file.}

\item{inner_file}{Character scalar. The path/name of the TSV file within
`zipfile` (as understood by [unz()]).}

\item{skip}{Integer scalar. Number of initial lines that `readr::read_tsv()`
should skip. This is typically `2` for FFIEC schedule extracts (two-line
header). The returned text input retains these header lines so that the same
`skip` can be used for both connection and text inputs.}

\item{expected_cols}{Integer scalar. Expected number of columns (fields) in
the schedule (typically `length(cols)` from the parsed header).}

\item{tolerance}{Integer scalar. Maximum number of line-stitching iterations
(or similar safeguard) forwarded to [repair_ffiec_tsv_lines()]. Used to
prevent runaway repairs on severely corrupted input.}

\item{row_start_re}{Character scalar. Regular expression identifying “data”
lines (default matches lines beginning with a numeric ID followed by a tab).
This is used to restrict structural checks to true record lines.}
}
\value{
A list with two elements:
\describe{
  \item{input}{A list describing the prepared input, with either:
    \describe{
      \item{kind = "connection"}{Includes `con_open`, a function that returns a
        fresh [unz()] connection each time it is called.}
      \item{kind = "text"}{Includes `txt`, a single character string containing
        the full TSV text (header + repaired data) separated by `\\n`.}
    }
  }
  \item{repairs}{A character vector of repairs applied. Currently either empty
    (`character(0)`) or `"embedded-newline"` when repaired text is adopted.}
}
}
\description{
`ffiec_prepare_tsv_input()` constructs an input object suitable for
`readr::read_tsv()` from an FFIEC Call Report schedule stored in a ZIP file.
It is designed to address a common corruption pattern in these files:
**illegal embedded newlines** that split a logical record across multiple
physical lines.

The function reads the file once as raw lines, applies an embedded-newline
repair on the **data lines only**, and then decides whether to adopt the
repaired text based on a conservative structural check (field-count validity).

- If the repair does **not** improve structural validity, the function returns
  a connection-based input (`unz()`), leaving the original bytes untouched.
- If the repair **does** improve structural validity, the function returns a
  text-based input containing the original header lines plus the repaired data
  lines.
}
\details{
**Structural validity gate.** The embedded-newline repair is adopted only if it
reduces the number of “bad” data lines, where a line is “bad” if it appears to
be a data record (`row_start_re`) but does not have exactly `expected_cols`
fields (i.e., `str_count("\\t") + 1 != expected_cols`). This prevents
downstream parse/type errors caused by applying delimiter-sensitive operations
(e.g., trimming tabs) before record boundaries are stabilized.

**Line ending normalization.** Stray carriage returns (`\\r`) are removed from
line ends before analysis and repair.
}
\seealso{
[repair_ffiec_tsv_lines()] for the embedded-newline stitching logic;
  [ffiec_read_tsv_strict()] for parsing and diagnostics using the prepared input.
}
\keyword{internal}
