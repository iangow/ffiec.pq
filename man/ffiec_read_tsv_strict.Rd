% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ffeic_read.R
\name{ffiec_read_tsv_strict}
\alias{ffiec_read_tsv_strict}
\title{Read a prepared FFIEC TSV input with strict diagnostics}
\usage{
ffiec_read_tsv_strict(
  prepped_input,
  cols,
  colspec,
  skip = 2L,
  quote = "",
  na = c("", "NA", "CONF"),
  progress = FALSE,
  show_col_types = FALSE
)
}
\arguments{
\item{prepped_input}{A list describing the prepared input. Must include
`kind`, and either:
\describe{
  \item{kind = "connection"}{A `con_open` function returning a fresh
    connection each call.}
  \item{kind = "text"}{A `txt` character string containing TSV content.}
}}

\item{cols}{Character vector of column names passed to `col_names`.}

\item{colspec}{A readr column specification passed to `col_types`.}

\item{skip}{Integer scalar. Number of initial lines to skip (passed to
[readr::read_tsv()] for both input modes to ensure identical behavior).}

\item{quote}{Character scalar. Quoting character(s) passed to
[readr::read_tsv()]. For FFIEC schedule extracts this is typically `""`
(no quoting).}

\item{na}{Character vector. Values to treat as missing (passed to `na`).}

\item{progress}{Logical. Whether readr should show progress.}

\item{show_col_types}{Logical. Whether readr should print inferred column types.}
}
\value{
A list with elements:
\describe{
  \item{ok}{Logical. `TRUE` iff no warnings were captured and
    `readr::problems(df)` has zero rows.}
  \item{df}{A tibble on success; `NULL` on hard error.}
  \item{warnings}{Character vector of captured warning messages (possibly empty).}
  \item{problems}{A tibble of parsing problems from [readr::problems()]. Empty
    tibble if none or if a hard error occurred before a data frame existed.}
  \item{error}{Present only on hard error (`try-error` object).}
}
}
\description{
`ffiec_read_tsv_strict()` is a thin wrapper around [readr::read_tsv()] that
provides **strict** success criteria and consistent behavior across input
types produced by [ffiec_prepare_tsv_input()].

It supports two input modes:
\describe{
  \item{Connection input}{A `con_open()` factory that returns a fresh connection
  (typically from [unz()]).}
  \item{Text input}{A single character string containing the full TSV text.}
}

The function captures and muffles warnings, collects parsing problems via
[readr::problems()], and reports whether the read is “clean” (no warnings and
no recorded problems).
}
\details{
- Warnings are captured and muffled so that callers can decide whether they
  should trigger a fallback/repair strategy.
- Connections opened via `prepped_input$con_open()` are always closed on exit.
- `skip` is applied in both connection and text modes to keep the parse
  contract identical regardless of where the input came from.
}
\seealso{
[ffiec_prepare_tsv_input()] to construct `prepped_input`;
  [readr::read_tsv()] for the underlying parser.
}
\keyword{internal}
